"""WebSocket å®¢æˆ·ç«¯åŸºç±» - æä¾›é€šç”¨çš„å®¢æˆ·ç«¯åŠŸèƒ½"""

from __future__ import annotations

import asyncio
import logging
from abc import ABC, abstractmethod
from typing import Any, Callable, Dict, Optional, Set

from .client_ws_connection import ClientNetworkDriver, EventType, NetworkEvent
from .ws_config import ClientConfig

logger = logging.getLogger(__name__)


class WebSocketClientBase(ABC):
    """WebSocket å®¢æˆ·ç«¯åŸºç±» - æä¾›é€šç”¨çš„å®¢æˆ·ç«¯åŠŸèƒ½

    æ‰€æœ‰å®¢æˆ·ç«¯éƒ½åº”è¯¥ç»§æ‰¿è¿™ä¸ªåŸºç±»ï¼Œå®ç°ç‰¹å®šçš„è¿æ¥å’Œå‘é€é€»è¾‘ã€‚
    """

    def __init__(self, default_config: Optional[ClientConfig] = None):
        self.default_config = default_config

        custom_logger = default_config.get_logger() if default_config else None
        self.logger = custom_logger if custom_logger else logging.getLogger(__name__)

        self.network_driver = ClientNetworkDriver(custom_logger=custom_logger)

        self.event_queue: asyncio.Queue = asyncio.Queue()
        self.running = False
        self.dispatcher_task: Optional[asyncio.Task] = None

        self._connected_count = 0

        self.custom_handlers: Dict[str, Callable[[Dict[str, Any]], None]] = {}
        if default_config:
            self.custom_handlers = default_config.custom_handlers.copy()

        self.stats = {
            "connect_attempts": 0,
            "successful_connects": 0,
            "failed_connects": 0,
            "messages_received": 0,
            "messages_sent": 0,
            "custom_messages_processed": 0,
            "reconnect_attempts": 0,
            "active_handler_tasks": 0,
        }

        self.active_handler_tasks: Set[asyncio.Task] = set()
        self.task_counter = 0

    def register_custom_handler(
        self, message_type: str, handler: Callable[[Dict[str, Any]], None]
    ) -> None:
        """æ³¨å†Œè‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å™¨"""
        if not message_type.startswith("custom_"):
            message_type = f"custom_{message_type}"
        self.custom_handlers[message_type] = handler
        logger.info(f"æ³¨å†Œè‡ªå®šä¹‰å¤„ç†å™¨: {message_type}")

    def unregister_custom_handler(self, message_type: str) -> None:
        """æ³¨é”€è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å™¨"""
        if not message_type.startswith("custom_"):
            message_type = f"custom_{message_type}"
        self.custom_handlers.pop(message_type, None)
        logger.info(f"æ³¨é”€è‡ªå®šä¹‰å¤„ç†å™¨: {message_type}")

    async def _cleanup_completed_tasks(self) -> None:
        """æ¸…ç†å·²å®Œæˆçš„handlerä»»åŠ¡"""
        completed_tasks = {task for task in self.active_handler_tasks if task.done()}
        self.active_handler_tasks -= completed_tasks
        self.stats["active_handler_tasks"] = len(self.active_handler_tasks)

        # è·å–ä»»åŠ¡ç»“æœå¹¶è®°å½•å¼‚å¸¸
        for task in completed_tasks:
            try:
                await task
            except Exception as e:
                logger.error(f"Handler taskå¼‚å¸¸: {e}")

    async def _create_handler_task(self, coro, description: str = "handler") -> None:
        """åˆ›å»ºå¹¶ç®¡ç†handlerä»»åŠ¡"""
        self.task_counter += 1
        task_id = self.task_counter

        # åˆ›å»ºä»»åŠ¡åŒ…è£…å™¨ï¼Œç”¨äºå¼‚å¸¸å¤„ç†å’Œæ—¥å¿—
        async def task_wrapper():
            try:
                await coro
                logger.debug(f"âœ… Client handler task {task_id} ({description}) å®Œæˆ")
            except Exception as e:
                logger.error(
                    f"âŒ Client handler task {task_id} ({description}) å¼‚å¸¸: {e}"
                )
                import traceback

                logger.error(f"   Traceback: {traceback.format_exc()}")
            finally:
                # ä»»åŠ¡å®Œæˆåè‡ªåŠ¨æ¸…ç†
                if task in self.active_handler_tasks:
                    self.active_handler_tasks.remove(task)
                self.stats["active_handler_tasks"] = len(self.active_handler_tasks)

        task = asyncio.create_task(task_wrapper())
        self.active_handler_tasks.add(task)
        self.stats["active_handler_tasks"] = len(self.active_handler_tasks)

        logger.debug(
            f"ğŸš€ Client handler task {task_id} ({description}) å·²åˆ›å»ºï¼Œå½“å‰æ´»è·ƒä»»åŠ¡æ•°: {len(self.active_handler_tasks)}"
        )

    async def _handle_message_event(self, event: NetworkEvent) -> None:
        """å¤„ç†æ¶ˆæ¯äº‹ä»¶ - å­ç±»å¯ä»¥é‡å†™æ­¤æ–¹æ³•"""
        try:
            payload = event.payload
            self.stats["messages_received"] += 1

            # å¤„ç†æ ‡å‡†æ¶ˆæ¯
            if payload.get("type") == "sys_std":
                if self.default_config and self.default_config.on_message:
                    try:
                        # å­ç±»å¯ä»¥é‡å†™è¿™ä¸ªæ–¹æ³•æ¥å¤„ç†æ ‡å‡†æ¶ˆæ¯
                        await self._handle_standard_message(payload)
                    except Exception as e:
                        logger.error(f"å¤„ç†æ ‡å‡†æ¶ˆæ¯æ—¶å‡ºé”™: {e}")

            # å¤„ç†è‡ªå®šä¹‰æ¶ˆæ¯
            elif payload.get("type", "").startswith("custom_"):
                message_type = payload.get("type")
                message_data = payload.get("payload", {})
                self.stats["custom_messages_processed"] += 1

                if message_type in self.custom_handlers:
                    try:
                        await self._create_handler_task(
                            self.custom_handlers[message_type](message_data),
                            f"å®¢æˆ·ç«¯è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å™¨-{message_type}",
                        )
                    except Exception as e:
                        logger.error(
                            f"åˆ›å»ºè‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å™¨ä»»åŠ¡é”™è¯¯ {message_type}: {e}"
                        )
                else:
                    logger.warning(f"æœªæ‰¾åˆ°è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å™¨: {message_type}")

        except Exception as e:
            logger.error(f"å¤„ç†æ¶ˆæ¯äº‹ä»¶æ—¶å‡ºé”™: {e}")

    async def _handle_standard_message(self, payload: Dict[str, Any]) -> None:
        """å¤„ç†æ ‡å‡†æ¶ˆæ¯ - å­ç±»å¯ä»¥é‡å†™æ­¤æ–¹æ³•"""
        if self.default_config and self.default_config.on_message:
            message_data = payload.get("payload", {})
            if message_data:
                from .message import APIMessageBase

                message = APIMessageBase.from_dict(message_data)
                await self._create_handler_task(
                    self.default_config.on_message(message, payload.get("meta", {})),
                    "å®¢æˆ·ç«¯æ ‡å‡†æ¶ˆæ¯å¤„ç†å™¨",
                )

    async def _event_dispatcher(self) -> None:
        """äº‹ä»¶åˆ†å‘å™¨"""
        logger.info(f"{self.__class__.__name__} event dispatcher started")
        try:
            while self.running:
                try:
                    event = await asyncio.wait_for(self.event_queue.get(), timeout=1.0)

                    # å­ç±»å¤„ç†è¿æ¥äº‹ä»¶
                    if event.event_type == EventType.CONNECT:
                        await self._handle_connect_event(event)
                    elif event.event_type == EventType.DISCONNECT:
                        await self._handle_disconnect_event(event)
                    elif event.event_type == EventType.MESSAGE:
                        await self._handle_message_event(event)

                except asyncio.TimeoutError:
                    # æ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡å¹¶ç»§ç»­å¾ªç¯
                    await self._cleanup_completed_tasks()
                    continue
                except Exception as e:
                    logger.error(f"Dispatcher error: {e}")

        except Exception as e:
            logger.error(f"Event dispatcher crashed: {e}")

        logger.info(f"{self.__class__.__name__} event dispatcher stopped")

    @abstractmethod
    async def _handle_connect_event(self, event: NetworkEvent) -> None:
        """å¤„ç†è¿æ¥äº‹ä»¶ - å­ç±»å¿…é¡»å®ç°"""
        pass

    @abstractmethod
    async def _handle_disconnect_event(self, event: NetworkEvent) -> None:
        """å¤„ç†æ–­è¿äº‹ä»¶ - å­ç±»å¿…é¡»å®ç°"""
        pass

    async def start(self) -> None:
        """å¯åŠ¨å®¢æˆ·ç«¯"""
        if self.running:
            logger.warning(f"{self.__class__.__name__} is already running")
            return

        self.running = True
        self.network_driver.set_event_queue(self.event_queue)

        if self.default_config and self.default_config.enable_message_cache:
            from .message_cache import MessageCache

            message_cache = MessageCache(
                enabled=self.default_config.enable_message_cache,
                ttl=self.default_config.message_cache_ttl,
                max_size=self.default_config.message_cache_max_size,
                cleanup_interval=self.default_config.message_cache_cleanup_interval,
                custom_logger=self.default_config.get_logger(),
            )
            await message_cache.start()
            self.network_driver.set_message_cache(message_cache)
            logger.info(
                f"Message cache initialized: TTL={self.default_config.message_cache_ttl}s, max_size={self.default_config.message_cache_max_size}"
            )

        # å¯åŠ¨ç½‘ç»œé©±åŠ¨å™¨
        await self.network_driver.start()

        # å¯åŠ¨äº‹ä»¶åˆ†å‘å™¨
        self.dispatcher_task = asyncio.create_task(self._event_dispatcher())
        logger.info(f"{self.__class__.__name__} started")

    async def stop(self) -> None:
        """åœæ­¢å®¢æˆ·ç«¯ - å®Œå…¨æ¸…ç†æ‰€æœ‰åç¨‹"""
        if not self.running:
            return

        logger.info(f"Stopping {self.__class__.__name__}...")

        # 1. é¦–å…ˆåœæ­¢è¿è¡ŒçŠ¶æ€
        self.running = False

        # 2. å–æ¶ˆäº‹ä»¶åˆ†å‘å™¨åç¨‹
        if self.dispatcher_task and not self.dispatcher_task.done():
            self.dispatcher_task.cancel()
            try:
                await asyncio.wait_for(self.dispatcher_task, timeout=2.0)
            except (asyncio.CancelledError, asyncio.TimeoutError):
                pass
        self.dispatcher_task = None

        # 3. åœæ­¢ç½‘ç»œé©±åŠ¨å™¨ï¼ˆè¿™ä¼šæ¸…ç†æ‰€æœ‰è¿æ¥åç¨‹ï¼‰
        await self.network_driver.stop()

        # 4. å–æ¶ˆå¹¶ç­‰å¾…æ‰€æœ‰handlerä»»åŠ¡å®Œæˆ
        if self.active_handler_tasks:
            logger.info(
                f"æ­£åœ¨æ¸…ç† {len(self.active_handler_tasks)} ä¸ªå®¢æˆ·ç«¯handlerä»»åŠ¡..."
            )
            for task in self.active_handler_tasks:
                if not task.done():
                    task.cancel()

            # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆæˆ–è¶…æ—¶
            if self.active_handler_tasks:
                try:
                    await asyncio.wait_for(
                        asyncio.gather(
                            *self.active_handler_tasks, return_exceptions=True
                        ),
                        timeout=3.0,
                    )
                except asyncio.TimeoutError:
                    logger.warning("éƒ¨åˆ†å®¢æˆ·ç«¯handlerä»»åŠ¡æ¸…ç†è¶…æ—¶")

            self.active_handler_tasks.clear()
            self.stats["active_handler_tasks"] = 0

        # 5. æ¸…ç©ºäº‹ä»¶é˜Ÿåˆ—
        while not self.event_queue.empty():
            try:
                self.event_queue.get_nowait()
            except asyncio.QueueEmpty:
                break

        # 5. é‡ç½®ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            "messages_sent": 0,
            "messages_received": 0,
            "connection_errors": 0,
            "reconnections": 0,
            "custom_messages_processed": 0,
        }

        logger.info(f"{self.__class__.__name__} stopped completely")

    def get_stats(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        network_stats = self.network_driver.get_stats()
        return {
            **self.stats,
            "network": network_stats,
        }

    def is_running(self) -> bool:
        """æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦åœ¨è¿è¡Œ"""
        return self.running

    def get_coroutine_status(self) -> Dict[str, Any]:
        """è·å–åç¨‹çŠ¶æ€ä¿¡æ¯"""
        status = {
            "client_running": self.running,
            "dispatcher_task": None,
            "network_driver_running": False,
            "event_queue_size": 0,
        }

        # æ£€æŸ¥äº‹ä»¶åˆ†å‘å™¨çŠ¶æ€
        if self.dispatcher_task:
            status["dispatcher_task"] = {
                "exists": True,
                "done": self.dispatcher_task.done(),
                "cancelled": self.dispatcher_task.cancelled()
                if hasattr(self.dispatcher_task, "cancelled")
                else False,
            }

        # æ£€æŸ¥ç½‘ç»œé©±åŠ¨å™¨çŠ¶æ€
        status["network_driver_running"] = (
            self.network_driver.running
            if hasattr(self.network_driver, "running")
            else False
        )

        # æ£€æŸ¥äº‹ä»¶é˜Ÿåˆ—å¤§å°
        try:
            status["event_queue_size"] = self.event_queue.qsize()
        except AttributeError:
            pass

        return status
